# FLASHBANG-SPECIFIC CLOUDFORMATION IMPROVEMENTS
# Based on the actual FlashBang honeypot architecture and modules

AWSTemplateFormatVersion: '2010-09-09'
Description: Enhanced FlashBang Honeypot with complete service stack

Parameters:
  # Add missing parameters from README
  FlashBangGitRepo:
    Type: String
    Default: "https://github.com/your-org/flashbang-honeypot.git"
    Description: Git repository URL for FlashBang source code

  AbuseIPDBKey:
    Type: String
    Description: AbuseIPDB API key for threat intelligence
    Default: ""
    NoEcho: true

  VirusTotalAPIKey:
    Type: String
    Description: VirusTotal API key for malware analysis
    Default: ""
    NoEcho: true

  SlackWebhookURL:
    Type: String
    Description: Slack webhook URL for alerts
    Default: ""
    NoEcho: true

  HoneypotMode:
    Type: String
    Default: "medium"
    AllowedValues: ["low", "medium", "high"]
    Description: Honeypot interaction level per FlashBang documentation

  EnableInteractiveServices:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: Enable SSH, FTP, Telnet honeypots

  EnableWebHoneypot:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: Enable web application honeypot module

Resources:
  # CORE EC2 INSTANCE WITH FLASHBANG STACK
  FlashBangInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      SubnetId: !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref FlashBangSecurityGroup
      IamInstanceProfile: !Ref FlashBangInstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e
          
          # System updates and dependencies
          yum update -y
          yum install -y python3 python3-pip git nginx docker sqlite3 htop fail2ban
          
          # Install Node.js for potential web components
          curl -sL https://rpm.nodesource.com/setup_18.x | bash -
          yum install -y nodejs
          
          # Install Docker Compose
          curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          
          # Start and enable services
          systemctl start docker nginx
          systemctl enable docker nginx
          usermod -aG docker ec2-user
          
          # Create FlashBang directories
          mkdir -p /opt/flashbang/{logs,data,certs,scripts}
          chown -R ec2-user:ec2-user /opt/flashbang
          
          # Clone FlashBang repository
          cd /opt
          git clone ${FlashBangGitRepo} flashbang-src || echo "Using local files"
          cp -r flashbang-src/* flashbang/ 2>/dev/null || true
          
          # Install Python dependencies from requirements.txt
          cd /opt/flashbang
          pip3 install -r requirements.txt || pip3 install flask flask-limiter boto3 requests aiofiles asyncssh pyftpdlib redis psutil
          
          # Create FlashBang configuration
          cat > /opt/flashbang/config.json << 'EOF'
          {
            "mode": "${HoneypotMode}",
            "aws": {
              "region": "${AWS::Region}",
              "s3_bucket": "${FlashBangLogsBucket}",
              "dynamodb_table": "${AttackAnalyticsTable}",
              "sns_topic": "${FlashBangAlerts}"
            },
            "services": {
              "flask_app": {"enabled": true, "port": 5000, "host": "127.0.0.1"},
              "ssh_honeypot": {"enabled": ${EnableInteractiveServices}, "port": 2222, "host": "0.0.0.0"},
              "ftp_honeypot": {"enabled": ${EnableInteractiveServices}, "port": 21, "host": "0.0.0.0"},
              "telnet_honeypot": {"enabled": ${EnableInteractiveServices}, "port": 23, "host": "0.0.0.0"},
              "web_honeypot": {"enabled": ${EnableWebHoneypot}, "port": 8080, "host": "127.0.0.1"}
            },
            "threat_intel": {
              "enabled": "${EnableThreatIntel}",
              "abuseipdb_key": "${AbuseIPDBKey}",
              "virustotal_key": "${VirusTotalAPIKey}"
            },
            "alerting": {
              "email": "${NotificationEmail}",
              "slack_webhook": "${SlackWebhookURL}",
              "sns_topic": "${FlashBangAlerts}"
            },
            "logging": {
              "enable_cloudwatch": ${EnableCloudWatchLogs},
              "enable_s3_backup": ${EnableS3LogBackup},
              "log_level": "INFO"
            }
          }
          EOF
          
          # Set environment variables
          cat > /opt/flashbang/.env << 'EOF'
          FLASK_ENV=production
          FLASK_APP=app.py
          AWS_REGION=${AWS::Region}
          AWS_DEFAULT_REGION=${AWS::Region}
          HONEYPOT_MODE=${HoneypotMode}
          ENABLE_THREAT_INTEL=${EnableThreatIntel}
          ABUSEIPDB_KEY=${AbuseIPDBKey}
          VIRUSTOTAL_API_KEY=${VirusTotalAPIKey}
          SNS_TOPIC_ARN=${FlashBangAlerts}
          SLACK_WEBHOOK_URL=${SlackWebhookURL}
          S3_BUCKET=${FlashBangLogsBucket}
          DYNAMODB_TABLE=${AttackAnalyticsTable}
          ENABLE_S3_BACKUP=${EnableS3LogBackup}
          ENABLE_CLOUDWATCH_LOGS=${EnableCloudWatchLogs}
          EOF
          
          # Configure Nginx for FlashBang
          cat > /etc/nginx/conf.d/flashbang.conf << 'EOF'
          # FlashBang Honeypot Nginx Configuration
          
          log_format flashbang_format '$remote_addr - $remote_user [$time_local] '
                                     '"$request" $status $body_bytes_sent '
                                     '"$http_referer" "$http_user_agent" '
                                     '"$http_x_forwarded_for" "$request_time"';
          
          upstream flask_app {
              server 127.0.0.1:5000;
          }
          
          upstream web_honeypot {
              server 127.0.0.1:8080;
          }
          
          server {
              listen 80 default_server;
              server_name _;
              
              # Real IP handling
              real_ip_header X-Forwarded-For;
              real_ip_recursive on;
              
              # Custom logging for attack analysis
              access_log /var/log/nginx/flashbang_access.log flashbang_format;
              error_log /var/log/nginx/flashbang_error.log;
              
              # Rate limiting for protection
              limit_req_zone $binary_remote_addr zone=flashbang:10m rate=10r/s;
              limit_req zone=flashbang burst=20 nodelay;
              
              # Main Flask application
              location / {
                  proxy_pass http://flask_app;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_read_timeout 300s;
                  proxy_connect_timeout 75s;
              }
              
              # Web application honeypot for specific vulnerable paths
              location ~ ^/(admin|wp-admin|phpmyadmin|cPanel|webmin) {
                  proxy_pass http://web_honeypot;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              }
              
              # Honeypot endpoints for common attack vectors
              location ~ \.(env|git|sql|bak|backup|db|config|log)$ {
                  proxy_pass http://flask_app;
                  access_log /var/log/nginx/flashbang_attacks.log flashbang_format;
              }
              
              # API endpoints for web honeypot
              location /api/ {
                  proxy_pass http://web_honeypot;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              }
          }
          EOF
          
          # Remove default Nginx config
          rm -f /etc/nginx/sites-enabled/default /etc/nginx/conf.d/default.conf
          
          # Create systemd services for FlashBang components
          
          # Main Flask app service
          cat > /etc/systemd/system/flashbang-flask.service << 'EOF'
          [Unit]
          Description=FlashBang Flask Honeypot
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          Group=ec2-user
          WorkingDirectory=/opt/flashbang
          Environment=PATH=/usr/local/bin:/usr/bin:/bin
          EnvironmentFile=/opt/flashbang/.env
          ExecStart=/usr/bin/python3 /opt/flashbang/app.py
          Restart=always
          RestartSec=5
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # Interactive services honeypot
          cat > /etc/systemd/system/flashbang-interactive.service << 'EOF'
          [Unit]
          Description=FlashBang Interactive Services Honeypot
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          Group=ec2-user
          WorkingDirectory=/opt/flashbang
          Environment=PATH=/usr/local/bin:/usr/bin:/bin
          EnvironmentFile=/opt/flashbang/.env
          ExecStart=/usr/bin/python3 /opt/flashbang/interactive_services.py
          Restart=always
          RestartSec=5
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # Web application honeypot
          cat > /etc/systemd/system/flashbang-web.service << 'EOF'
          [Unit]
          Description=FlashBang Web Application Honeypot
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          Group=ec2-user
          WorkingDirectory=/opt/flashbang
          Environment=PATH=/usr/local/bin:/usr/bin:/bin
          EnvironmentFile=/opt/flashbang/.env
          ExecStart=/usr/bin/python3 /opt/flashbang/web_honeypot.py
          Restart=always
          RestartSec=5
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # Log rotation configuration
          cat > /etc/logrotate.d/flashbang << 'EOF'
          /opt/flashbang/logs/*.log {
              daily
              missingok
              rotate 30
              compress
              delaycompress
              notifempty
              create 644 ec2-user ec2-user
              postrotate
                  /bin/kill -USR1 `cat /run/nginx.pid 2>/dev/null` 2>/dev/null || true
              endscript
          }
          
          /var/log/nginx/flashbang_*.log {
              daily
              missingok
              rotate 30
              compress
              delaycompress
              notifempty
              create 644 nginx nginx
              postrotate
                  /bin/kill -USR1 `cat /run/nginx.pid 2>/dev/null` 2>/dev/null || true
              endscript
          }
          EOF
          
          # Install CloudWatch agent for advanced monitoring
          wget https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
          rpm -U ./amazon-cloudwatch-agent.rpm
          
          # CloudWatch agent configuration
          cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
          {
            "agent": {
              "run_as_user": "root"
            },
            "logs": {
              "logs_collected": {
                "files": {
                  "collect_list": [
                    {
                      "file_path": "/opt/flashbang/logs/attacks.log",
                      "log_group_name": "${FlashBangLogGroup}",
                      "log_stream_name": "{instance_id}/flashbang-attacks",
                      "timezone": "UTC"
                    },
                    {
                      "file_path": "/var/log/nginx/flashbang_access.log",
                      "log_group_name": "${FlashBangLogGroup}",
                      "log_stream_name": "{instance_id}/nginx-access",
                      "timezone": "UTC"
                    },
                    {
                      "file_path": "/var/log/nginx/flashbang_attacks.log",
                      "log_group_name": "${FlashBangLogGroup}",
                      "log_stream_name": "{instance_id}/nginx-attacks",
                      "timezone": "UTC"
                    }
                  ]
                }
              }
            },
            "metrics": {
              "namespace": "FlashBang/Honeypot",
              "metrics_collected": {
                "cpu": {
                  "measurement": ["cpu_usage_idle", "cpu_usage_iowait", "cpu_usage_user", "cpu_usage_system"],
                  "metrics_collection_interval": 60
                },
                "disk": {
                  "measurement": ["used_percent"],
                  "metrics_collection_interval": 60,
                  "resources": ["*"]
                },
                "mem": {
                  "measurement": ["mem_used_percent"],
                  "metrics_collection_interval": 60
                },
                "netstat": {
                  "measurement": ["tcp_established", "tcp_time_wait"],
                  "metrics_collection_interval": 60
                }
              }
            }
          }
          EOF
          
          # Create backup script
          cat > /opt/flashbang/scripts/backup_logs.sh << 'EOF'
          #!/bin/bash
          # FlashBang log backup script
          
          DATE=$(date +%Y-%m-%d)
          BACKUP_DIR="/opt/flashbang/logs/backup"
          S3_BUCKET="${FlashBangLogsBucket}"
          
          mkdir -p $BACKUP_DIR
          
          # Archive logs
          tar -czf $BACKUP_DIR/flashbang-logs-$DATE.tar.gz /opt/flashbang/logs/*.log /var/log/nginx/flashbang_*.log
          
          # Upload to S3
          aws s3 cp $BACKUP_DIR/flashbang-logs-$DATE.tar.gz s3://$S3_BUCKET/backups/
          
          # Clean up old local backups (keep 7 days)
          find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete
          
          # Export database
          sqlite3 /opt/flashbang/flashbang_attacks.db ".backup $BACKUP_DIR/flashbang-db-$DATE.sqlite"
          aws s3 cp $BACKUP_DIR/flashbang-db-$DATE.sqlite s3://$S3_BUCKET/database-backups/
          EOF
          
          chmod +x /opt/flashbang/scripts/backup_logs.sh
          
          # Add to crontab for automated backups
          echo "0 2 * * * /opt/flashbang/scripts/backup_logs.sh" | crontab -u ec2-user -
          
          # Create monitoring script
          cat > /opt/flashbang/scripts/health_check.sh << 'EOF'
          #!/bin/bash
          # FlashBang health monitoring script
          
          SERVICES=("flashbang-flask" "flashbang-interactive" "flashbang-web" "nginx")
          ALL_HEALTHY=true
          
          echo "FlashBang Health Check - $(date)"
          echo "================================"
          
          for service in "$${SERVICES[@]}"; do
              if systemctl is-active --quiet $service; then
                  echo "âœ“ $service: Running"
              else
                  echo "âœ— $service: NOT Running"
                  ALL_HEALTHY=false
                  # Attempt restart
                  systemctl restart $service
                  sleep 5
                  if systemctl is-active --quiet $service; then
                      echo "  â†’ $service: Restarted successfully"
                  else
                      echo "  â†’ $service: Failed to restart"
                  fi
              fi
          done
          
          # Check port availability
          PORTS=(80 2222 21 23 5000 8080)
          for port in "$${PORTS[@]}"; do
              if netstat -tlnp | grep -q ":$port "; then
                  echo "âœ“ Port $port: Open"
              else
                  echo "âœ— Port $port: Closed"
                  ALL_HEALTHY=false
              fi
          done
          
          # Check disk space
          DISK_USAGE=$(df /opt/flashbang | awk 'NR==2 {print $5}' | sed 's/%//')
          if [ $DISK_USAGE -gt 85 ]; then
              echo "âš  Disk usage: $DISK_USAGE% (HIGH)"
              ALL_HEALTHY=false
          else
              echo "âœ“ Disk usage: $DISK_USAGE%"
          fi
          
          if [ "$ALL_HEALTHY" = true ]; then
              echo "âœ“ All systems healthy"
              exit 0
          else
              echo "âœ— Some issues detected"
              exit 1
          fi
          EOF
          
          chmod +x /opt/flashbang/scripts/health_check.sh
          
          # Add health check to crontab (every 5 minutes)
          echo "*/5 * * * * /opt/flashbang/scripts/health_check.sh >> /opt/flashbang/logs/health.log 2>&1" | crontab -u ec2-user -
          
          # Set proper permissions
          chown -R ec2-user:ec2-user /opt/flashbang
          chmod -R 755 /opt/flashbang
          
          # Reload systemd and start services
          systemctl daemon-reload
          systemctl enable flashbang-flask flashbang-interactive flashbang-web
          systemctl restart nginx
          
          # Start CloudWatch agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
          
          # Wait for network to be ready, then start FlashBang services
          sleep 30
          systemctl start flashbang-flask flashbang-interactive flashbang-web
          
          # Final health check
          sleep 10
          /opt/flashbang/scripts/health_check.sh
          
          # Log successful deployment
          echo "FlashBang honeypot deployment completed at $(date)" >> /opt/flashbang/logs/deployment.log
          
          # Send success notification
          if [ ! -z "${SlackWebhookURL}" ]; then
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"ðŸŽ¯ FlashBang honeypot successfully deployed and running!"}' \
                ${SlackWebhookURL} || true
          fi

      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-flashbang-honeypot"
        - Key: Purpose
          Value: FlashBang-Honeypot
        - Key: Environment
          Value: Production

  # ENHANCED SECURITY GROUP FOR ALL FLASHBANG SERVICES
  FlashBangSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-flashbang-sg"
      GroupDescription: Security group for FlashBang honeypot with all service ports
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        # Administrative access
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref MyIP
          Description: SSH admin access
        # HTTP/HTTPS from ALB
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref ALBSecurityGroup
          Description: HTTP from ALB
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref ALBSecurityGroup
          Description: HTTPS from ALB
        # FlashBang honeypot services (direct access for testing)
        - IpProtocol: tcp
          FromPort: 21
          ToPort: 21
          CidrIp: 0.0.0.0/0
          Description: FTP honeypot
        - IpProtocol: tcp
          FromPort: 23
          ToPort: 23
          CidrIp: 0.0.0.0/0
          Description: Telnet honeypot
        - IpProtocol: tcp
          FromPort: 2222
          ToPort: 2222
          CidrIp: 0.0.0.0/0
          Description: SSH honeypot
        # Database honeypots
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
          Description: MySQL honeypot
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          CidrIp: 0.0.0.0/0
          Description: PostgreSQL honeypot
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          CidrIp: 0.0.0.0/0
          Description: Redis honeypot
        # Windows services
        - IpProtocol: tcp
          FromPort: 3389
          ToPort: 3389
          CidrIp: 0.0.0.0/0
          Description: RDP honeypot
        - IpProtocol: tcp
          FromPort: 445
          ToPort: 445
          CidrIp: 0.0.0.0/0
          Description: SMB honeypot
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: All outbound traffic
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-flashbang-sg"

  # CLOUDWATCH LOG GROUP FOR FLASHBANG
  FlashBangLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/ec2/${AWS::StackName}/flashbang"
      RetentionInDays: 30
      Tags:
        - Key: Purpose
          Value: FlashBang-Logging

  # ENHANCED LAMBDA FOR FLASHBANG LOG PROCESSING
  FlashBangLogProcessorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-flashbang-processor"
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt LogProcessorLambdaRole.Arn
      Timeout: 900
      MemorySize: 1024
      ReservedConcurrentExecutions: 10
      Environment:
        Variables:
          SNS_TOPIC_ARN: !If [CreateSNSTopic, !Ref FlashBangAlerts, ""]
          SLACK_WEBHOOK: !If [EnableSlack, !Ref SlackWebhookURL, ""]
          DYNAMODB_TABLE: !Ref AttackAnalyticsTable
          ENABLE_THREAT_INTEL: !Ref EnableThreatIntel
          ABUSEIPDB_KEY: !Ref AbuseIPDBKey
          VIRUSTOTAL_API_KEY: !Ref VirusTotalAPIKey
          HONEYPOT_MODE: !Ref HoneypotMode
          FLASHBANG_MODE: "true"
      Code:
        ZipFile: |
          import json
          import boto3
          import gzip
          import base64
          import os
          import re
          import requests
          from collections import defaultdict, Counter
          from datetime import datetime, timedelta
          from urllib.parse import unquote

          # Initialize AWS clients
          s3 = boto3.client('s3')
          sns = boto3.client('sns')
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])

          def lambda_handler(event, context):
              """Enhanced FlashBang log processor"""
              try:
                  for record in event['Records']:
                      bucket = record['s3']['bucket']['name']
                      key = record['s3']['object']['key']
                      
                      # Download and process log file
                      response = s3.get_object(Bucket=bucket, Key=key)
                      
                      if key.endswith('.gz'):
                          content = gzip.decompress(response['Body'].read()).decode('utf-8')
                      else:
                          content = response['Body'].read().decode('utf-8')
                      
                      # Determine log type and process accordingly
                      if 'nginx' in key:
                          report = analyze_nginx_logs(content)
                      elif 'flashbang' in key or 'attacks' in key:
                          report = analyze_flashbang_logs(content)
                      else:
                          report = analyze_generic_logs(content)
                      
                      # Store analytics and send alerts
                      store_flashbang_analytics(report)
                      
                      if should_alert_flashbang(report):
                          send_flashbang_alerts(report)
                      
                  return {'statusCode': 200, 'body': 'FlashBang log processing complete'}
              except Exception as e:
                  print(f"FlashBang processor error: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}

          def analyze_flashbang_logs(content):
              """Analyze FlashBang-specific attack logs"""
              lines = content.strip().split('\n')
              
              # FlashBang-specific patterns
              flashbang_patterns = {
                  'rickroll_triggered': r'rickroll.*triggered',
                  'fake_shell_access': r'shell.*access.*attempt',
                  'honeypot_interaction': r'honeypot.*interaction',
                  'deception_triggered': r'deception.*engine.*triggered',
                  'threat_intel_hit': r'threat.*intelligence.*match'
              }
              
              attack_summary = {
                  'total_interactions': 0,
                  'unique_ips': set(),
                  'flashbang_specific': Counter(),
                  'attack_types': Counter(),
                  'high_risk_ips': set(),
                  'deception_effectiveness': 0,
                  'timestamp': datetime.now().isoformat()
              }
              
              for line in lines:
                  if not line.strip():
                      continue
                      
                  attack_summary['total_interactions'] += 1
                  
                  # Extract IP
                  ip_match = re.search(r'(\d+\.\d+\.\d+\.\d+)', line)
                  if ip_match:
                      ip = ip_match.group(1)
                      attack_summary['unique_ips'].add(ip)
                  
                  # Check FlashBang-specific patterns
                  line_lower = line.lower()
                  for pattern_name, pattern in flashbang_patterns.items():
                      if re.search(pattern, line_lower):
                          attack_summary['flashbang_specific'][pattern_name] += 1
                          if pattern_name in ['threat_intel_hit', 'deception_triggered']:
                              attack_summary['deception_effectiveness'] += 1
                          break
                  
                  # Traditional attack pattern detection
                  if re.search(r'sql.*injection|union.*select|drop.*table', line_lower):
                      attack_summary['attack_types']['sql_injection'] += 1
                      if ip_match:
                          attack_summary['high_risk_ips'].add(ip_match.group(1))
                  
                  if re.search(r'<script|javascript:|xss', line_lower):
                      attack_summary['attack_types']['xss'] += 1
                  
                  if re.search(r'cmd.*exec|shell.*injection', line_lower):
                      attack_summary['attack_types']['command_injection'] += 1
                      if ip_match:
                          attack_summary['high_risk_ips'].add(ip_match.group(1))
              
              # Convert sets to lists for JSON serialization
              attack_summary['unique_ips'] = list(attack_summary['unique_ips'])
              attack_summary['high_risk_ips'] = list(attack_summary['high_risk_ips'])
              attack_summary['flashbang_specific'] = dict(attack_summary['flashbang_specific'])
              attack_summary['attack_types'] = dict(attack_summary['attack_types'])
              
              return attack_summary

          def analyze_nginx_logs(content):
              """Analyze Nginx access logs for FlashBang"""
              lines = content.strip().split('\n')
              
              summary = {
                  'total_requests': 0,
                  'unique_ips': set(),
                  'status_codes': Counter(),
                  'user_agents': Counter(),
                  'top_endpoints': Counter(),
                  'suspicious_requests': 0,
                  'timestamp': datetime.now().isoformat()
              }
              
              for line in lines:
                  if not line.strip():
                      continue
                      
                  summary['total_requests'] += 1
                  
                  # Parse Nginx log format: IP - - [timestamp] "request" status size "referer" "user-agent"
                  parts = line.split(' ')
                  if len(parts) >= 7:
                      ip = parts[0]
                      status_code = parts[6] if parts[6] != '-' else '000'
                      
                      summary['unique_ips'].add(ip)
                      summary['status_codes'][status_code] += 1
                      
                      # Extract request from quotes
                      if '"' in line:
                          request_match = re.search(r'"([^"]+)"', line)
                          if request_match:
                              request = request_match.group(1)
                              method_and_endpoint = request.split(' ')
                              if len(method_and_endpoint) > 1:
                                  endpoint = method_and_endpoint[1]
                                  summary['top_endpoints'][endpoint] += 1
                                  
                                  # Check for suspicious patterns in endpoint
                                  suspicious_patterns = [
                                      r'\.env', r'\.git', r'admin', r'wp-', r'sql', 
                                      r'script', r'union', r'select', r'<script', r'javascript:',
                                      r'cmd', r'exec', r'system', r'eval'
                                  ]
                                  
                                  endpoint_lower = endpoint.lower()
                                  for pattern in suspicious_patterns:
                                      if re.search(pattern, endpoint_lower):
                                          summary['suspicious_requests'] += 1
                                          break
                      
                      # Extract user agent (last quoted string)
                      ua_matches = re.findall(r'"([^"]*)"', line)
                      if len(ua_matches) >= 2:  # Usually referer and user-agent
                          user_agent = ua_matches[-1]  # Last one is typically user-agent
                          if user_agent and user_agent != '-':
                              summary['user_agents'][user_agent] += 1
              
              # Convert sets to lists for JSON serialization
              summary['unique_ips'] = list(summary['unique_ips'])
              summary['status_codes'] = dict(summary['status_codes'])
              summary['user_agents'] = dict(summary['user_agents'].most_common(10))
              summary['top_endpoints'] = dict(summary['top_endpoints'].most_common(20))
              
              return summary

          def analyze_generic_logs(content):
              """Fallback for other log types"""
              lines = content.strip().split('\n')
              
              return {
                  'total_lines': len([line for line in lines if line.strip()]),
                  'contains_attacks': len([line for line in lines if 'attack' in line.lower()]),
                  'timestamp': datetime.now().isoformat(),
                  'log_type': 'generic'
              }

          def store_flashbang_analytics(report):
              """Store FlashBang analytics in DynamoDB"""
              try:
                  # Store summary record
                  summary_item = {
                      'ip_address': 'SUMMARY',
                      'timestamp': report['timestamp'],
                      'total_interactions': report.get('total_interactions', 0),
                      'unique_ips_count': len(report.get('unique_ips', [])),
                      'ttl': int((datetime.now() + timedelta(days=90)).timestamp())
                  }
                  
                  # Add FlashBang-specific data if present
                  if 'flashbang_specific' in report:
                      summary_item['flashbang_patterns'] = json.dumps(report['flashbang_specific'])
                  if 'attack_types' in report:
                      summary_item['attack_types'] = json.dumps(report['attack_types'])
                  if 'deception_effectiveness' in report:
                      summary_item['deception_effectiveness'] = report['deception_effectiveness']
                  
                  table.put_item(Item=summary_item)
                  
                  # Store individual high-risk IPs (limit to prevent throttling)
                  high_risk_ips = report.get('high_risk_ips', [])
                  for ip in high_risk_ips[:10]:
                      table.put_item(
                          Item={
                              'ip_address': ip,
                              'timestamp': report['timestamp'],
                              'risk_level': 'HIGH',
                              'flagged_by': 'FlashBang',
                              'attack_count': report.get('total_interactions', 0),
                              'ttl': int((datetime.now() + timedelta(days=90)).timestamp())
                          }
                      )
                      
              except Exception as e:
                  print(f"Failed to store FlashBang analytics: {e}")

          def should_alert_flashbang(report):
              """Determine if FlashBang should send alerts"""
              # High interaction count
              if report.get('total_interactions', 0) > 500:
                  return True
              
              # High number of requests (for nginx logs)
              if report.get('total_requests', 0) > 1000:
                  return True
              
              # Multiple high-risk IPs
              if len(report.get('high_risk_ips', [])) > 3:
                  return True
              
              # High suspicious request rate
              total_requests = report.get('total_requests', 0)
              suspicious_requests = report.get('suspicious_requests', 0)
              if total_requests > 0 and (suspicious_requests / total_requests) > 0.5:
                  return True
              
              # Effective deception (attackers are being fooled)
              if report.get('deception_effectiveness', 0) > 10:
                  return True
              
              # Specific FlashBang patterns triggered
              flashbang_patterns = report.get('flashbang_specific', {})
              if flashbang_patterns.get('threat_intel_hit', 0) > 5:
                  return True
              
              return False

          def send_flashbang_alerts(report):
              """Send FlashBang-specific alerts"""
              message = format_flashbang_alert(report)
              
              # Send SNS alert
              sns_topic = os.environ.get('SNS_TOPIC_ARN')
              if sns_topic:
                  try:
                      subject = f"ðŸŽ¯ FlashBang Alert - {report.get('total_interactions', report.get('total_requests', 0))} interactions"
                      sns.publish(
                          TopicArn=sns_topic,
                          Subject=subject,
                          Message=message
                      )
                  except Exception as e:
                      print(f"Failed to send SNS alert: {e}")
              
              # Send Slack alert
              slack_webhook = os.environ.get('SLACK_WEBHOOK')
              if slack_webhook:
                  try:
                      slack_payload = format_flashbang_slack_alert(report)
                      requests.post(slack_webhook, json=slack_payload, timeout=10)
                  except Exception as e:
                      print(f"Failed to send Slack alert: {e}")

          def format_flashbang_alert(report):
              """Format FlashBang alert message"""
              total_activity = report.get('total_interactions', report.get('total_requests', 0))
              
              message = f"""
          ðŸŽ¯ FlashBang Honeypot Activity Report
          
          ðŸ“Š Activity Summary:
          â€¢ Total Activity: {total_activity:,}
          â€¢ Unique IPs: {len(report.get('unique_ips', [])):,}
          â€¢ High-Risk IPs: {len(report.get('high_risk_ips', [])):,}
          """
              
              # Add FlashBang-specific patterns if available
              if 'flashbang_specific' in report:
                  message += "â€¢ Deception Effectiveness: {}\n".format(report.get('deception_effectiveness', 0))
                  message += "\nðŸŽª FlashBang-Specific Detections:\n"
                  for pattern, count in report['flashbang_specific'].items():
                      if count > 0:
                          message += f"â€¢ {pattern.replace('_', ' ').title()}: {count:,}\n"
              
              # Add attack types
              if 'attack_types' in report:
                  message += "\nðŸŽ¯ Attack Types:\n"
                  for attack_type, count in report['attack_types'].items():
                      if count > 0:
                          message += f"â€¢ {attack_type.replace('_', ' ').title()}: {count:,}\n"
              
              # Add suspicious requests for nginx logs
              if 'suspicious_requests' in report and report['suspicious_requests'] > 0:
                  message += f"\nâš ï¸ Suspicious Requests: {report['suspicious_requests']:,}\n"
              
              # Add top endpoints if available
              if 'top_endpoints' in report:
                  message += "\nðŸ”¥ Top Targeted Endpoints:\n"
                  for endpoint, count in list(report['top_endpoints'].items())[:5]:
                      message += f"â€¢ {endpoint}: {count:,}\n"
              
              # Add high-risk IPs
              if report.get('high_risk_ips'):
                  message += f"\nðŸš¨ High-Risk IPs:\n"
                  for ip in report['high_risk_ips'][:5]:
                      message += f"â€¢ {ip}\n"
              
              message += f"\nâ° Report Generated: {report.get('timestamp', 'Unknown')}"
              
              return message

          def format_flashbang_slack_alert(report):
              """Format FlashBang Slack alert with rich formatting"""
              total_activity = report.get('total_interactions', report.get('total_requests', 0))
              high_risk_count = len(report.get('high_risk_ips', []))
              effectiveness = report.get('deception_effectiveness', 0)
              
              # Choose emoji based on activity level
              if effectiveness > 20:
                  effectiveness_emoji = "ðŸŽ¯"
                  color = "good"
              elif effectiveness > 10:
                  effectiveness_emoji = "ðŸŽª"
                  color = "warning"
              elif high_risk_count > 10:
                  effectiveness_emoji = "ðŸš¨"
                  color = "danger"
              else:
                  effectiveness_emoji = "ðŸŽ­"
                  color = "good"
              
              fields = [
                  {
                      "title": "Total Activity",
                      "value": f"{total_activity:,}",
                      "short": True
                  },
                  {
                      "title": "Unique IPs",
                      "value": f"{len(report.get('unique_ips', [])):,}",
                      "short": True
                  },
                  {
                      "title": "High-Risk IPs",
                      "value": f"{high_risk_count}",
                      "short": True
                  }
              ]
              
              # Add deception effectiveness if available
              if effectiveness > 0:
                  fields.append({
                      "title": "Deception Success",
                      "value": f"{effectiveness} fooled attackers",
                      "short": True
                  })
              
              return {
                  "text": f"ðŸŽ¯ FlashBang captured {total_activity:,} interactions from {len(report.get('unique_ips', [])):,} unique IPs",
                  "attachments": [
                      {
                          "color": color,
                          "title": f"{effectiveness_emoji} FlashBang Honeypot Activity",
                          "fields": fields,
                          "footer": "FlashBang Honeypot System",
                          "ts": int(datetime.now().timestamp())
                      }
                  ]
              }